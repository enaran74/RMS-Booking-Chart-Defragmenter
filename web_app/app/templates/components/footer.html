<!-- Session Timer (left side) -->
<div class="session-timer" id="sessionTimer" style="display: none;">
  <i class="fas fa-clock me-1"></i>
  <span id="sessionCountdown">29:59</span>
</div>

<!-- Version Stamp (right side) -->
<div class="version-stamp" id="versionStamp">RMS Defragmenter • loading...</div>
<style>
  .version-stamp{
    position: fixed;
    right: 12px;
    bottom: 10px;
    font-size: 11px;
    color: #6c757d;
    background: rgba(255,255,255,0.85);
    border: 1px solid rgba(0,0,0,0.05);
    border-radius: 6px;
    padding: 4px 8px;
    z-index: 1040;
    pointer-events: none;
  }
  .session-timer{
    position: fixed;
    left: 12px;
    bottom: 10px;
    font-size: 11px;
    color: #6c757d;
    background: rgba(255,255,255,0.9);
    border: 1px solid rgba(0,0,0,0.1);
    border-radius: 6px;
    padding: 4px 8px;
    z-index: 1040;
    pointer-events: none;
    transition: color 0.3s ease;
  }
  .session-timer.warning{
    color: #fd7e14;
    border-color: rgba(253, 126, 20, 0.2);
    background: rgba(255, 243, 205, 0.9);
  }
  .session-timer.danger{
    color: #dc3545;
    border-color: rgba(220, 53, 69, 0.2);
    background: rgba(248, 215, 218, 0.9);
    animation: pulse 1s infinite;
  }
  @keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
  }
  .version-stamp .badge{ margin-left:6px; }
</style>
<script>
  (function(){
    try{
      var el = document.getElementById('versionStamp');
      if(!el) return;
      
      // Fetch dynamic version from API with static fallback
      function renderStamp(version, isoTimestamp){
        // Prefer server-provided build timestamp (from VERSION_INFO mtime); fallback to lastModified
        var ts = isoTimestamp ? new Date(isoTimestamp) : new Date(document.lastModified || Date.now());
        
        // Preserve any existing badges before updating text
        var existingBadges = el.querySelectorAll('.badge');
        var badgeNodes = Array.from(existingBadges);
        
        el.textContent = 'RMS Defragmenter ' + version + ' • loaded ' + ts.toLocaleString();
        
        // Re-append preserved badges
        badgeNodes.forEach(function(badge) {
          el.appendChild(badge);
        });
      }
      
      // Function to add training/live badge
      function addTrainingBadge() {
        // Remove any existing badges first
        var existingBadges = el.querySelectorAll('.badge');
        existingBadges.forEach(function(badge) { badge.remove(); });
        
        // Determine training status
        var training = (window.APP_USE_TRAINING_DB === true);
        console.log('[Footer] Initial training flag:', training);
        
        try{
          var meta = document.querySelector('meta[name="use-training-db"]');
          console.log('[Footer] Meta tag found:', meta);
          if(meta){
            var c = (meta.content || '').toString().trim().toLowerCase();
            training = (c === 'true' || c === '1' || c === 'yes');
            console.log('[Footer] Meta content:', meta.content, 'parsed as training:', training);
            // expose for any other scripts
            window.APP_USE_TRAINING_DB = training;
          } else {
            console.log('[Footer] No meta tag found for use-training-db');
          }
        }catch(e){
          console.error('[Footer] Error reading meta tag:', e);
        }
        
        console.log('[Footer] Final training flag:', training);
        if(training){
          var b = document.createElement('span');
          b.className = 'badge bg-warning text-dark';
          b.textContent = 'TRAINING';
          el.appendChild(b);
          console.log('[Footer] Added TRAINING badge');
        } else {
          var b = document.createElement('span');
          b.className = 'badge bg-success';
          b.textContent = 'LIVE';
          el.appendChild(b);
          console.log('[Footer] Added LIVE badge');
        }
      }

      // Prefer raw version (reads VERSION_INFO) for accuracy, zero dependencies
      fetch('/api/v1/version-raw')
        .then(r => {
          if(!r.ok) throw new Error('version-raw ' + r.status);
          return r.text();
        })
        .then(text => {
          var version = (text || '').trim() || 'v1.0.0-unknown';
          console.log('[Footer] version-raw:', version);
          // Try to fetch stable build timestamp from static JSON endpoint
          fetch('/api/v1/version/static')
            .then(r => r.ok ? r.json() : Promise.reject('static meta ' + r.status))
            .then(meta => { 
              renderStamp(version, meta && meta.timestamp);
              addTrainingBadge();
            })
            .catch(() => { 
              renderStamp(version);
              addTrainingBadge();
            });
        })
        .catch(err => {
          // Try plain text fallback
          fetch('/version.txt')
            .then(r => r.ok ? r.text() : Promise.reject('version.txt ' + r.status))
            .then(text => { 
              renderStamp((text||'').trim() || 'v1.0.0-unknown');
              addTrainingBadge();
            })
            .catch(() => {
              // Fallback to dynamic API; still render client-local time
              fetch('/api/v1/version')
                .then(r => r.ok ? r.json() : Promise.reject('version api ' + r.status))
                .then(data => { 
                  renderStamp(data.version || 'v1.0.0-unknown');
                  addTrainingBadge();
                })
                .catch(err2 => { 
                  renderStamp('v1.0.0-unknown');
                  addTrainingBadge();
                  console.warn('Version fetch fallback used:', err, err2);
                });
            });
        });
        
    }catch(e){
      console.warn('Version stamp initialization failed:', e);
    }
  })();
</script>

